---
title: "Vignette: Penalized Regression Techniques"
author: Aleksander Cichosz, Anni Li, Brian Che, Justin Vo, Noa Rapoport
format: html
editor: visual
execute:
  message: false
  warning: false
  echo: true
  cache: true
---

## Introduction

Penalized regression is an alternative to the standard linear model that allows us to create a regression model that is penalized by adding a constraint in the equation. This allows us to reduce the coefficent values towards zero, allowing the less contributive variables to have a coefficient close or equal to zero.

**Objectives**

In this vignette you'll learn how to implement:

-   Ridge Regression
-   LASSO Regression
-   Elastic Net Regression

**Setup**  
First, we need to load all the required packages and import the data

```{r, echo = TRUE}
# load packages
library(tidyverse)
library(tidymodels)
library(modelr)
library(rsample)
library(yardstick)
library(DataExplorer)
library(Matrix)
library(glmnet)
library(rsample)
library(dplyr)
library(caret)

# read data
url  <- 'https://raw.githubusercontent.com/pstat197/vignette-regression/main/data/life_clean.csv'

life_clean <- read.csv(url)
```

**About Our Dataset: Life Expectancy (WHO)**

## Exploratory Data Analysis

For the project, we wanted to find a data set where analyzing the regression between explanatory and response variables would have an interesting and valuable result. For this reason we decided to analyze the WHO Life Expectancy data-set and look at the relationship between factors that affect one's health such as country, vaccinations given in that said country, infant mortality rate in the country, etc., and see how these factors might explain the life expectancy. In this dataset, there are 1649 observations and 20 measurements, one being life expectancy.

## Data Partitioning

```{r}
# for consistency across linear, ridge-regression, and LASSO
set.seed(13)

# partitioning data into training and test set
partitions <- life_clean %>%
  initial_split(prop = 0.8)

# creating training set
train <- training(partitions)
train %>% head(4)

# creating test set
test <- testing(partitions)
test %>% head(4)
```

## Simple Linear Regression

We will use a simple linear regression model as a basis for comparing all other models. This base model has the life expectancy as a linear function of all the other variables in the dataset.

```{r}
# Model fitting on training set
lin_mod <- lm(Life.expectancy ~ ., data = train)

# Predictions for test set based on fitted model
pred_lin <- predict(lin_mod, newdata = test)
```

To evaluate the model performance, we will look at the $R^2$ and the Test Mean Squared Error (MSE).
```{r}
# R Squared
rss <- sum((pred_lin - test$Life.expectancy)^ 2)
tss <- sum((test$Life.expectancy - mean(test$Life.expectancy)) ^ 2)
rsq <- 1 - rss/tss
rsq

# Mean Squared Error
test_mse <- mean((pred_lin - test$Life.expectancy)^2)
test_mse
```

#### Results
Here, we see that our base linear regression model has a $R^2$ value of 0.829 and a test MSE of 12.907. We will use these as a basis for comparing the performance of the penalized regression models.

## Ridge Regression

#### Background

Ridge regression, which is also referred to as L2 regularization, is a method used when we have highly correlated parameters. This issue of multicollinearity in linear regression can return biased results. Multicollinearity will usually inflate the standard error of terms, resulting in inaccurate P values. Estimates will be biased and cannot be trusted. Ridge regression adds a penalization factor to linear regression. This penalization factor is the ridge parameter and is the tuning for ridge regression. Overall, ridge regression replace our residual estimation with residual plus a penalization term. So when we are minimizing our residuals the penalization term comes into effect.

The package we will be working with for ridge regression is glmnet. There are some requirements for data formatting for this package. This means that our response variable will have to be in a vector. Our explanatory variables will have to be in a matrix. We will reformat the training and testing set objects we created earlier to achieve this.

```{r}
# splitting predictors and response variable in training set
train_x <- train %>%
  select(-Life.expectancy) %>%
  as.matrix()
train_y <- train %>%
  pull(Life.expectancy)

# splitting predictors and response variable in test set
test_x <- test %>%
  select(-Life.expectancy) %>%
  as.matrix()
test_y <- test %>%
  pull(Life.expectancy)
```

Unlike linear regression, ridge regression is a regularized regression model that uses lambda as our tuning parameter, meaning we are going to try to find an optimal lambda as usually done by brute force.

The *glmnet()* function trains the model multiple times for different values of lambda, passing them through its argument as a sequence of vector as mentioned before. Here, we use cross-validation to get the best model, which we do by using the *cv.glmnet()* function to automate the process of identify the optimal value of lambda that will result in a minimum error.

```{r}
# Setting the range of lambda values
lambda_seq <- 10^seq(2, -3, by = -.1)

# Using glmnet function to build the ridge regression in r
fit <- glmnet(train_x, train_y, alpha = 0, lambda  = lambda_seq)

# Checking the model
summary(fit)

# Using cross validation glmnet
ridge_cv <- cv.glmnet(train_x, train_y, alpha = 0, lambda = lambda_seq)

# Acquire best lambda value
best_lambda <- ridge_cv$lambda.min
best_lambda
```

The optimal lambda value, which produces the lowest test mean squared error (MSE), comes out to be 0.01 and will be used to build the ridge regression model for which we pass it through the lambda value.

```{r}
# extract the best model using K-cross validation
best_fit <- ridge_cv$glmnet.fit

# Rebuilding the model with optimal lambda value 0.01
best_ridge <- glmnet(train_x, train_y, alpha = 0, lambda = 0.01)

# Checking the coefficients
coef(best_ridge)
```

We then compute the $R^2$ value from the true and predicted values.

```{r}
# apply prediction model to test_x
pred <- predict(best_ridge, s = best_lambda, newx = test_x)

# use prediction function and R squared formula to compute R^2 value
actual <- test_y
rss <- sum((pred - actual) ^ 2)
tss <- sum((actual - mean(actual)) ^ 2)
rsq <- 1 - rss/tss
rsq # 0.8278766

# Mean Squared Error
test_mse <- mean((pred - actual)^2)
test_mse
```

#### Results

The R-squared value for the ridge regression model on the testing data outputs to be **82.79%**, which is a **slight decrease in performance** compared with the linear regression model at a R-squared value of **82.90%.** The MSE for our test partition set is **12.995**, which is slightly higher than the the test MSE of the linear regression model.

## LASSO Regression

#### Background

LASSO (Least Absolute Shrinkage and Selection Operator) regression is a type of regression that shrinks the coefficients of the base linear regression model. It has the effect of forcing some of the coefficient estimates to be exactly zero and performs variable selection. Similar to Ridge, LASSO  is well suited for datasets where multicollinearity may be present.

LASSO adds a penalty by performing L1 regularization, which penalizes the sum of absolute values of the coefficients. This can be seen in the function below, which we want to miniimize:

$\sum_{i=1}^{n}{(y_i - \sum_{j}{x_{ij}\beta_j})^2} + \lambda \sum_{j=1}^{p}|\beta_j|$

Lambda is the tuning parameter for LASSO regression. We will find the optimal lambda value through cross validation. We will use the glmnet package for LASSO jsut like ridge. We will also use the same training and test set that we created in the ridge regression section.

```{r}
# lambda values we will choose from
lambdas <- 10^seq(2, -3, by = -.1)

# Perform cross validation to find best value of lambda
lasso_reg <- cv.glmnet(train_x, train_y, alpha = 1, lambda = lambdas)

# Best lambda value
best_lambda <- lasso_reg$lambda.min

best_lambda
```

We now fit the model by specifying the optimal lambda, and alpha = 1 which corresponds to LASSO regression.

```{r}
# Model fit on training set and optimal lambda value
lasso_mod <- glmnet(train_x, train_y, alpha = 1, lambda = best_lambda, standardize = TRUE)

# Checking the coefficients
coef(lasso_mod)
```

We will now apply the model to the test set to come up with a set of test predictions.

```{r}
# Apply fitted model on test set
pred_lasso <- predict(lasso_mod, s = best_lambda, newx = test_x)
```

Using these predicted test values and actual test values, we will compute the test MSE to see how our model performed.

```{r}
# R Squared
actual <- test_y
rss <- sum((pred_lasso - actual) ^ 2)
tss <- sum((actual - mean(actual)) ^ 2)
rsq <- 1 - rss/tss
rsq 

# Test Mean Squared Error
mse <- mean((pred_lasso-actual)^2)
mse
```

#### Results

The R-squared value for the LASSO regression model on the testing data outputs to be **82.88%**, which is a **slight decrease in performance** compared with the linear regression model at a R-squared value of **82.90%.** The MSE for our test partition set is **12.918**, which is slightly higher than the the test MSE of 12.907 of the linear regression model.

## Elastic Net Regression

```{r, results='hide'}
# remove some categorical variables
df <- life_clean
x <- df %>% select(-c(Life.expectancy))

# Model Building : Elastic Net Regression
control <- trainControl(method = "repeatedcv",
                        number = 5,
                        repeats = 5,
                        search = "random",
                        verboseIter = TRUE)

# Training ELastic Net Regression model
elastic_model <- train(Life.expectancy ~ .,
                       data = df,
                       method = "glmnet",
                       preProcess = c("center", "scale"),
                       tuneLength = 25,
                       trControl = control)
```

```{r}
# Model Prediction
x_hat_pre <- predict(elastic_model, x)

# Multiple R-squared
rsq <- cor(df$Life.expectancy, x_hat_pre)^2
rsq

# Mean Squared Error
mse <- mean((x_hat_pre - df$Life.expectancy)^2)
mse
```

## Conclusion
